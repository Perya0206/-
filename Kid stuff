const { VK, Keyboard } = require('vk-io')
const VKC = require('node-vkcoinapi')
const mongoose = require('mongoose')
const fs = require('fs')
const { QuestionManager } = require('vk-io-question');
const config = require('./config.json')
const utils = require('./utils')
const questionManager = new QuestionManager();

mongoose.connect(config.mongodb, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})

const vk = new VK({
  token: config.botToken,
  apiMode: 'parallel',
  apiLimit: 20,
})

const vkcoin = new VKC({
  key: config.bot.key,
  userId: config.bot.id,
  token: config.bot.token,
})

const userSchema = {
  id: {
    type: Number,
    required: true,
  },
  refId: {
    type: Number,
  },
  referrals: {
    type: Number,
    required: true,
    default: 0,
  },
  firstName: {
    type: String,
    required: true,
  },
  balance: {
    type: Number,
    required: true,
    default: 0,
  },
  depositBalance: {
    type: Number,
    required: true,
    default: 0,
  },
  replenishBalance: {
    type: Number,
    required: true,
    default: 0,
  },
  reposts: [{
    type: Number,
  }],
  isAdmin: {
    type: Boolean,
    required: true,
    default: false,
  },
}

const User = mongoose.model('User', userSchema)

async function getUser (id, refId = 0) {
  let user = await User.findOne({ id })
  if (!user) {
    const { first_name } = (await vk.api.users.get({ user_ids: id }))[0]
    user = new User({id, refId, firstName: first_name, replenishBalance: refId ? 100000 : 0})
    await user.save()
    const refUser = await User.findOne({ id: refId })
    if (refUser) {
      refUser.replenishBalance += 100000
      refUser.referrals++
      await refUser.save()
    }
  }
  return user
}

const procent = 2;

function KeybroadPrivate (user) {
	const array = [
    [
      Keyboard.textButton({
        label: 'üìà –ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å',
        color: Keyboard.POSITIVE_COLOR,
      }),
     ],
     [
      Keyboard.textButton({
        label: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å',
        color:Keyboard.PRIMARY_COLOR,
      }),
      Keyboard.textButton({
        label: 'üèÜ –¢–æ–ø –∏–≥—Ä–æ–∫–æ–≤',
        color: Keyboard.PRIMARY_COLOR,
      }),
     ],
     [
    Keyboard.applicationButton({
      appId: 6915965,
      hash: `x${config.bot.id}_10000000_0_1`,
      label: '–ü–æ–ø–æ–ª–Ω–∏—Ç—å',
    }),
      Keyboard.textButton({
        label: 'üì§ –í—ã–≤–µ—Å—Ç–∏',
        color:Keyboard.NEGATIVE_COLOR,
			}),
		],
	]
	
	if (user.isAdmin) {
		array.push([
			Keyboard.textButton({
				color: Keyboard.NEGATIVE_COLOR,
				label: 'üòé –ê–¥–º–∏–Ω-–ü–∞–Ω–µ–ª—å',
			}),
		])
	}
	
	return Keyboard.keyboard(array)
}

const topKeyboard = Keyboard.keyboard([
  [
    Keyboard.textButton({
      color: Keyboard.PRIMARY_COLOR,
      label: 'üèÜ –¢–æ–ø –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤',
    }),
    Keyboard.textButton({
      color: Keyboard.PRIMARY_COLOR,
      label: 'üèÜ –¢–æ–ø —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤',
    }),
  ],
  [
    Keyboard.textButton({ color: Keyboard.NEGATIVE_COLOR, label: '–ú–µ–Ω—é', }),
  ],
]).oneTime()

const KeyboardCancel = Keyboard.keyboard([
	[
		Keyboard.textButton({ label: '–ù–∞–∑–∞–¥', color: Keyboard.NEGATIVE_COLOR }), 
	],
])

// - - - - - –°—Ç–∞—Ä—Ç - - - - - //

vk.updates.hear(/^(—Å—Ç–∞—Ä—Ç|start|–Ω–∞—á–∞—Ç—å|–º–µ–Ω—é)/i, async (context) => {
 context.send(`üéâ–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –Ω–∞ VKCoin's ‚Äî VkCoin Invest!`, { keyboard: KeybroadPrivate(_users) })
})

// - - - - - –ò–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å- - - - - //

vk.updates.hear(/^üìà –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å/i, async (context) => {
let id = context.senderId
let user = await User.findOne({ id: id })
const sum = await context.question(`üí∞ –í—ã –º–æ–∂–µ—Ç–µ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å: ${utils.split(user.replenishBalance)} VkCoin

	üí∂ –ë–∞–ª–∞–Ω—Å –¥–ª—è –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π: ${utils.split(user.replenishBalance)} VkCoin
	üí∑ –ë–∞–ª–∞–Ω—Å –¥–ª—è –≤—ã–≤–æ–¥–∞: ${utils.split(user.balance)} VkCoin

	üí≤–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å:`, { keyboard: KeyboardCancel })
  if(sum.text == '–ù–∞–∑–∞–¥') {
	return context.send('‚úÖ –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é!', { keyboard: KeybroadPrivate(_users) })
	}
const amount = Number(Number.parseFloat(sum.text.replace(/\s/g, '')).toFixed(3))
  if(!amount || isNaN(amount)) {
return context.send('–í—ã –≤–≤–µ–ª–∏ —á—Ç–æ-—Ç–æ –Ω–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!', { keyboard: KeybroadPrivate(_users) })
}
  if(amount > user.replenishBalance) {
  return context.send(`–ù–∞ —Ç–≤–æ—ë–º –±–∞–ª–∞–Ω—Å–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–∏–Ω–æ–≤.`)
}
  if(amount < 1) {
return context.send(`–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏ 1 –∫–æ–∏–Ω!`)
}
  user.replenishBalance -= amount
  user.depositBalance += amount
    await user.save()
await context.send(`‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–∏ ${utils.split(amount)} VkCoin`)
})

// - - - - - –ê–¥–º–∏–Ω–∫–∞ - - - - - //

vk.updates.hear(/^üòé –ê–¥–º–∏–Ω-–ü–∞–Ω–µ–ª—å/i, async (context) => {
	if (!_users.isAdmin) return
	await context.send(`üòé –í—ã–±–µ—Ä–∏ –∞–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—É –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.`, { keyboard: Keyboard.keyboard([
		[
			Keyboard.textButton({ label: "ü§ë –†–∞–∑–¥–∞—á–∞", color: Keyboard.POSITIVE_COLOR }), 
		],
		[
            Keyboard.textButton({ label: "üí∞–°—É–º–º–∞ –±–æ–Ω—É—Å–∞", color: Keyboard.PRIMARY_COLOR }),		
        ],
        [
			Keyboard.textButton({ label: "–ú–µ–Ω—é", color: Keyboard.NEGATIVE_COLOR }),		
		]
	])
	})
})

// - - - - - –†–∞–∑–¥–∞—á–∞ - - - - - //

vk.updates.hear(/^(?:\s+)?ü§ë –†–∞–∑–¥–∞—á–∞/i, async (context) => {
	if (!_users.isAdmin) return
	const args = await context.question(`üçÄ –¢–µ–∫—É—â–∏–π –∞–π–¥–∏ –ø–æ—Å—Ç–∞: ${config.post}
	‚úÖ –í–≤–µ–¥–∏ –∞–π–¥–∏ –Ω–æ–≤–æ–≥–æ –ø–æ—Å—Ç–∞:`, { keyboard: KeyboardCancel })
	if(args.text == `–ù–∞–∑–∞–¥`) {
		return context.send(`–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–∏–ª–∏ —Å–º–µ–Ω—É –∞–π–¥–∏ –ø–æ—Å—Ç–∞.`, { keyboard: KeybroadPrivate(_users) })
	}
	const post_id = Number.parseFloat(args.text)
	if(!post_id) {
		return context.send(`–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:`, { keyboard: KeybroadPrivate(_users) }, { keyboard: KeybroadPrivate(_users) })
	}
	config.post = post_id 
	fs.writeFileSync('./config.json', JSON.stringify(config, null, 2))
    await context.send(`‚úÖ –ê–π–¥–∏ –ø–æ—Å—Ç–∞ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: ${post_id}`,  { keyboard: KeybroadPrivate(_users) });
})

// - - - - - –°—É–º–º–∞ –±–æ–Ω—É—Å–∞ - - - - - //

vk.updates.hear(/^(?:\s+)?üí∞–°—É–º–º–∞ –±–æ–Ω—É—Å–∞/i, async (context) => {
	if (!_users.isAdmin) return
	const args = await context.question(`üçÄ –¢–µ–∫—É—â–∞—è —Å—É–º–º–∞ –±–æ–Ω—É—Å–∞: ${config.sumpost}
	‚úÖ –í–≤–µ–¥–∏ –∞–π–¥–∏ –Ω–æ–≤–æ–≥–æ –ø–æ—Å—Ç–∞:`, { keyboard: KeyboardCancel })
	if(args.text == `–ù–∞–∑–∞–¥`) {
		return context.send(`–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–∏–ª–∏ —Å–º–µ–Ω—É —Å—É–º–º—ã –±–æ–Ω—É—Å–∞.`, { keyboard: KeybroadPrivate(_users) })
	}
	const post_sum = Number.parseFloat(args.text)
	if(!post_sum) {
		return context.send(`–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:`, { keyboard: KeybroadPrivate(_users) }, { keyboard: KeybroadPrivate(_users) })
	}
	config.sumpost = post_sum
	fs.writeFileSync('./config.json', JSON.stringify(config, null, 2))
    await context.send(`‚úÖ –°—É–º–º–∞ –±–æ–Ω—É—Å–∞ –∏–∑–º–µ–Ω—ë–Ω–∞ –Ω–∞: ${post_sum}`,  { keyboard: KeybroadPrivate(_users) });
})

// - - - - - –ü—Ä–æ—Ñ–∏–ª—å - - - - - //

vk.updates.hear(/^üë§ –ø—Ä–æ—Ñ–∏–ª—å/i, async (context) => {
let id = context.senderId
let user = await User.findOne({ id: id })
await context.send(`üí¥ –ë–∞–ª–∞–Ω—Å –¥–ª—è –≤—ã–≤–æ–¥–∞: ${utils.split(user.balance)} VkCoin
üíµ –ë–∞–ª–∞–Ω—Å –¥–ª—è –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π: ${utils.split(user.replenishBalance)} VkCoin

üí∞–í—ã –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–ª–∏: ${utils.split(user.depositBalance)} VkCoin

üöÄ –í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞: vk.me/public199863656?ref=${context.senderId}
üß∏ –í—ã –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏: ${user.referrals} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.`)
})

// - - - - - –í—ã–≤–æ–¥ - - - - - //
vk.updates.hear(/^üì§ –≤—ã–≤–µ—Å—Ç–∏/i, async (context) => {
      const { balance } = _users
      const vkcbalance = await vkcoin.api.getMyBalance()
  if(balance < 1) {
return context.send(`–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –≤—ã–≤–æ–¥–∞ 1 VkCoin`, { keyboard: KeybroadPrivate(_users) })
}
  if(balance > vkcbalance) {
return context.send(`‚ùó–£ –±–æ—Ç–∞ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–∏–Ω–æ–≤ –¥–ª—è –≤—ã–ø–ª–∞—Ç—ã!`, { keyboard: KeybroadPrivate(_users) })
}
  _users.balance = 0
  await _users.save()
    try {
        await vkcoin.api.sendPayment(context.senderId, balance * 1000, true)
        await context.send(`‚úÖ –í—ã–≤–µ–¥–µ–Ω–æ ${utils.split(balance)} VkCoin`, { keyboard: KeybroadPrivate(_users) })
    } catch (_) {
        await context.send(`–í–æ –≤—Ä–µ–º—è –≤—ã–≤–æ–¥–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É!`)
  }
}) 

// - - - - - –¢–æ–ø—ã - - - - - //

vk.updates.hear(/^üèÜ —Ç–æ–ø(\s+—Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤)/i, async (context) => {
      const topWins = await User.find({}).sort({ referrals: -1 }).limit(5)
      let message = 'üèÜ –¢–æ–ø —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤:'
  topWins.forEach((item, index) => {
      message += `\n${index + 1}. [id${item.id}|${item.firstName}] –ø—Ä–∏–≥–ª–∞—Å–∏–ª ${utils.split(item.referrals)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π`
})
await context.send(message, { keyboard: KeybroadPrivate(_users) })
})

vk.updates.hear(/^üèÜ —Ç–æ–ø(\s+–∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤)/i, async (context) => {
      const topWins = await User.find({}).sort({ depositBalance: -1 }).limit(5)
      let message = 'üèÜ –¢–æ–ø –∏–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤:'
  topWins.forEach((item, index) => {
      message += `\n${index + 1}. [id${item.id}|${item.firstName}] –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–ª ${utils.split(item.depositBalance)} VkCoin`
})
await context.send(message, { keyboard: KeybroadPrivate(_users) })
})

vk.updates.hear(/^üèÜ —Ç–æ–ø –∏–≥—Ä–æ–∫–æ–≤/i, async (context) => {
await context.send(`üèÜ –í—ã–±–µ—Ä–∏ —Ç–æ–ø –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å:`, { keyboard: topKeyboard })
})

vk.updates.on('message', async (context, next) => {
  if (context.senderId < 0) return
  _users = await getUser(context.senderId, context.referralValue)

  return next()
})

vk.updates.on('new_wall_repost', async (context) => {
  const user = await User.findOne({ id: context.wall.ownerId })
  if (!user || user.reposts.includes(context.wall.copyHistory[0].id)) return
  const lastPostId = config.post
  if (lastPostId !== context.wall.copyHistory[0].id) return
  let a = await vk.api.groups.isMember({ group_id: –ê–ô–î–ò –ì–†–£–ü–ü–´, user_id: context.wall.ownerId })
  if(a == 0){
    return context.send(`üí∞–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –±—ã—Ç—å –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º –Ω–∞ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ.`)
  }
  user.reposts.push(context.wall.copyHistory[0].id)
  await user.save()
  user.replenishBalance += config.sumpost
  await user.save()
  await vk.api.messages.send({
    user_id: context.wall.ownerId,
    message: `üöÄ –í—ã –ø–æ–ª—É—á–∏–ª–∏ ${config.sumpost} VkCoin –∑–∞ —Ä–µ–ø–æ—Å—Ç!
‚úÖ –ö–æ–∏–Ω—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –±–∞–ª–∞–Ω—Å –¥–ª—è –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π.`,
  })
})

vkcoin.updates.startPolling().catch(console.error)
vk.updates.start().catch(console.error)
vk.updates.use(questionManager.middleware);

vkcoin.updates.onTransfer(async (event) => {
  const user = await User.findOne({ id: event.fromId })
  if (!user) {
    return
  }
  user.replenishBalance += event.amount / 1000
  await user.save()
  await vk.api.messages.send({
    peer_id: event.fromId,
    message: `‚úÖ –í–∞—à –±–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ ${utils.split(event.amount / 1000)} VkCoin`,
    disable_mentions: true,
  })
})

async function update() {
  let userList = await User.find({});
userList.forEach(async element => {
  if (element.depositBalance === 0) { return
  }
    element.balance += element.depositBalance * (procent / (24*60)) / 100
await User.updateOne({ 'id': element.id }, { $set: { 'balance': element.balance, 'depositBalance': element.depositBalance, } }, 
  function (err) {
     if (err) throw err
})
 })
}

setInterval(async() => {
  update(); 
}, 60000); 

console.log('Started') 
